---
title: "Git & GitHub for the Command Line"
format:
  revealjs:
    theme: simple
    slide-number: true
    css: styles.css 
    preview-links: true
    editor: visual
---

## The Basics: Getting Started

### 1. Cloning an Existing Repository

To get a copy of a remote repository from GitHub, use `git clone`.

```         
git clone [https://github.com/e-perl-NOAA/git-command-line.git](https://github.com/e-perl-NOAA/git-command-line.git)  
```

## The Basics: Getting Started

### 2. Staging and Committing

This is the **core loop** of Git.

-   `git status`: See which files have changed.

-   `git add <file>`: Stage changes for a file.

-   `git add .`: Stage all changes.

-   `git commit -m "Your commit message"`: Save the staged changes to your local history.

## The Basics: Getting Started
### 3. Pushing to GitHub

To share your local commits with the remote repository, use `git push`. `origin` is the default name for your remote, and `main` is the branch.

```         
git push origin main  
```

## Branching & Merging

### Why Use Branches?

Branches allow you to work on new features or bug fixes in **isolation** from the `main` branch, which keeps the main project stable.

### Basic Branch Commands

-   `git branch <branch-name>`: Create a new branch.

-   `git checkout <branch-name>`: Switch to an existing branch. (or `git switch` in newer Git)

-   `git checkout -b <branch-name>`: Create and switch in one step.

-   `git merge <branch-name>`: Merge changes from a specified branch into your current branch.

## Dealing with a Merge Conflict

### Scenario

Jon and I are working on a report. Jon makes a change on `main` and pushes it. I am working at the same time on a branch called `ep-changes` and edit the **same line** of code and push my change.

### The Conflict

When I try to merge my changes into `main` (either locally or through a pull request), Git will pause and report a **merge conflict**.

```         
# My terminal 
git checkout main 
git pull origin main # Pull the latest from Jon
git merge ep-changes 
```

**Expected output:**

```         
Auto-merging README.md 
CONFLICT (content): Merge conflict in README.md  
Automatic merge failed; fix conflicts and then commit the result.  
```

### Resolving the Conflict

The conflicting file (`README.md`) will contain special markers. You must manually edit the file to resolve the issue.

```         
# In the conflicting file... 
<<<<<<< HEAD
# git-command-line PRESENTATION
=======
# git-command-line presentation
>>>>>>> ep-changes
# Edit the file to the desired state, for example: 
# git-command-line presentation 
# Then, stage and commit the resolved file 
git add README.md
git commit -m "Resolved merge conflict"  
```

## Rewriting History: `amend` & `rebase`

### `git commit --amend`

Use this to modify your **last commit**. It's useful for fixing typos in a commit message, adding a forgotten file, or making a small fix.

**Caution:** You generally do **not** amend commits that have already been pushed to a shared branch. This is because it rewrites the git history, which can confuse collaborators. 
However, if you do end up doing this, you'll need to force push with `git push --force`. After that, your collaborators will need to sync their local copies with the updated history otherwise they will run into issues. To resolve those issues they will need to run `git fetch` followed by `git reset --hard origin/main` (or the appropriate branch name) or `git pull --rebase`.

#### Changing a commit message
```         
# Made a commit with a typo in the message 
git commit -m "Added more text to README.md flie"  
# Now, let's fix it 
git add . 
git commit --amend -m "Added more text to README.md file"  
```
This replaces the last commit with a new one, so the old commit history is gone.

#### Adding a forgotten file

```
# Create a new file or make a change
touch forgotten_file.txt

# Instead of making a new "oops, forgot a file" commit, you amend the previous one
git add forgotten_file.txt
git commit --amend --no-edit # This will add the file without changing the commit message
```

#### Fixing a small bug

```
# Made a commit with some new code
git commit -m "Implemented user login logic"

# Now you find a bug and fix it
# ... edit the code ...

# Stage the fix and amend the previous commit
git add .
git commit --amend -m "Implemented user login logic" # This updates the commit with the fix
```

## Interactive Rebasing: The Ultimate Cleanup

### What is Interactive Rebasing?

`git rebase -i` lets you rewrite a series of commits in your branch history. It's an essential tool for creating a clean, easy-to-read commit history before merging.

### Example: Squashing Commits

Let's say that I have been working on a feature and has a series of small "fix" commits I wants to combine into a single, clean commit.

```         
# View the last 3 commits on the current branch 
git log --oneline -3  
# Rebase the last 3 commits interactively 
git rebase -i HEAD~3  
```

Git will open your text editor.

**Original editor content:**

```         
pick 691e84a Added a new file for the feature 
pick 5c4456b Fix a typo 
pick f83f739 Forgot to add a comment  
```

To squash the last two commits into the first one, you would edit the file.

-   `squash` (`s`): Combines a commit into the previous one and prompts for a new commit message.

-   `fixup` (`f`): Combines a commit into the previous one and **discards** its commit message.

**Edited editor content:**

```         
pick 691e84a Added a new file for the feature 
squash 5c4456b Fix a typo 
fixup f83f739 Forgot to add a comment  
```

Save and close the editor. Git will then prompt you to write a single, clean commit message for the combined commits. The result is a single, clean commit in your history.

### VS Code

There is a much easier way to do this using VS Code by doing the following:
1. Install the GitLens extension
2. `CTL + SHIFT + P` and search "GitLens: Enable Interactive Rebase Editor"
3. Close out VS Code and reopen
4. `git rebase -i` should open the interactive rebase editor.
5. Generally `use git push -f` after doing this


## Final Takeaways

-   **Commit Often:** Save your work frequently with descriptive messages.

-   **Use Branches:** Create a new branch for each feature or bug fix.

-   **Pull First:** Always run `git pull` before starting work to get the latest changes.

-   **Don't Rebase Shared Branches:** `rebase` is a powerful tool for cleaning your **local** history, but never use it on a branch that has been shared with collaborators.

-   **When in Doubt, Ask!** There's a rich community and great documentation available.
